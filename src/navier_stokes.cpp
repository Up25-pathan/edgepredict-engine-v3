#include "navier_stokes.h"
#include "simulation.h" // Include full definition of Mesh and Node here
#include <iostream>
#include <vector>
#include <cmath>
#include <omp.h> // Include OpenMP if you parallelize loops here

// Constructor
NavierStokesSolver::NavierStokesSolver(const json& config) : config_data(config) {
    // Initialize default values or read from config
    grid_nx = grid_ny = grid_nz = 0;
    grid_cell_size = 0.0;
    inlet_velocity = Eigen::Vector3d::Zero();
    std::cout << "  NavierStokesSolver constructed." << std::endl;
}

// Destructor
NavierStokesSolver::~NavierStokesSolver() {}

// Grid Initialization
void NavierStokesSolver::initialize_grid(int nx, int ny, int nz, double cell_size) {
    grid_nx = nx;
    grid_ny = ny;
    grid_nz = nz;
    grid_cell_size = cell_size;
    int total_cells = nx * ny * nz;

    // Resize and initialize grid data vectors (example for pressure, velocity, temp)
    pressure_grid.resize(total_cells, 0.0); // Initialize pressure (e.g., atmospheric)
    velocity_grid.resize(total_cells, Eigen::Vector3d::Zero()); // Initialize velocity
    temperature_grid.resize(total_cells, config_data["physics_parameters"]["ambient_temperature_C"].get<double>()); // Initialize temperature
    heat_source_grid.resize(total_cells, 0.0); // Initialize heat sources
    is_boundary_cell.resize(total_cells, false); // Initialize boundary markers


    std::cout << "  Navier-Stokes grid initialized (" << nx << "x" << ny << "x" << nz << ")" << std::endl;
}

// Set Inlet Velocity
void NavierStokesSolver::set_inlet_velocity(const Eigen::Vector3d& vel) {
    inlet_velocity = vel;
    std::cout << "  Inlet velocity set to (" << vel.x() << ", " << vel.y() << ", " << vel.z() << ") m/s" << std::endl;
    // Apply this velocity to appropriate boundary cells in 'update_boundaries_and_sources' or 'update'
}


// --- NEW IMPLEMENTATION for handling boundaries and sources ---
void NavierStokesSolver::update_boundaries_and_sources(const Mesh& mesh, double ambient_temp, double strain_rate, const ThermalModel& thermal_model) {

    // --- 1. Reset/Clear Previous Boundary Conditions/Sources ---
    // Reset boundary markers and heat sources for this time step
    heat_source_grid.assign(grid_nx * grid_ny * grid_nz, 0.0);
    is_boundary_cell.assign(grid_nx * grid_ny * grid_nz, false);


    // --- 2. Iterate through Mesh Nodes to Apply Conditions ---
    // This loop can potentially be parallelized if grid updates are atomic/thread-safe,
    // but sequential is safer unless proven otherwise.
    // #pragma omp parallel for // POTENTIAL PARALLELIZATION POINT
    for (size_t i = 0; i < mesh.nodes.size(); ++i) { // Use .size()
        // Access Node using the Mesh reference provided
        const Node& node = mesh.nodes[i];
        const Eigen::Vector3d& node_pos = node.position;

        // --- a) Apply Tool Boundary Condition ---
        // Find the grid cell(s) corresponding to node_pos
        int cell_idx = find_cell_index_for_position(node_pos);
        if (cell_idx >= 0 && cell_idx < is_boundary_cell.size()) {
             // Mark this cell as part of the solid tool boundary
             is_boundary_cell[cell_idx] = true;
             // Apply no-slip condition (set fluid velocity to zero at the boundary)
             velocity_grid[cell_idx] = Eigen::Vector3d::Zero();
             // Optionally, set boundary temperature if needed by solver
             // temperature_grid[cell_idx] = node.temperature; // Direct temperature setting
        }


        // --- b) Apply Heat Source from Hot Nodes ---
        // Apply heat generated by FEA to the corresponding fluid cell
        // Check node.status using the enum
        if (node.temperature > ambient_temp + 10.0 && node.status == NodeStatus::OK) {
            // Calculate heat generation rate (W/m^3) using the passed thermal_model
            double heat_flux_density = thermal_model.calculate_heat_generation(node.stress, strain_rate);

            // Apply this heat flux density to the fluid grid cell(s) near node_pos
            if (cell_idx >= 0 && cell_idx < heat_source_grid.size()) {
                 double cell_volume = grid_cell_size * grid_cell_size * grid_cell_size;
                 // Add total heat generation rate (W) for this cell
                 // (Use atomic add if parallelizing this loop)
                 heat_source_grid[cell_idx] += heat_flux_density * cell_volume;
            }
        }
    }
    // --- End Loop ---

    // --- 3. Apply Other Boundary Conditions (Inlet, Outlet, Walls) ---
    // Example: Set inlet velocity, outlet pressure, wall conditions based on grid boundaries
    // This loop iterates over the boundaries of the CFD grid itself
    // #pragma omp parallel for // Can often be parallelized
    for(int k=0; k<grid_nz; ++k) {
        for(int j=0; j<grid_ny; ++j) {
            // Inlet (example at i=0 plane)
            int inlet_idx = get_grid_index(0, j, k);
             // Check index validity before accessing
             if (inlet_idx >= 0 && inlet_idx < velocity_grid.size() && !is_boundary_cell[inlet_idx]) {
                 velocity_grid[inlet_idx] = inlet_velocity;
                 temperature_grid[inlet_idx] = ambient_temp; // Assume inlet fluid is at ambient
            }

            // Outlet (example at i=grid_nx-1 plane, zero-gradient pressure)
            // int outlet_idx = get_grid_index(grid_nx-1, j, k);
            // if (outlet_idx >= 0 && outlet_idx < pressure_grid.size() && !is_boundary_cell[outlet_idx]) {
            //      int neighbor_idx = get_grid_index(grid_nx-2, j, k);
            //      if (neighbor_idx >= 0) pressure_grid[outlet_idx] = pressure_grid[neighbor_idx]; // Zero gradient
            // }

            // Other walls (e.g., top/bottom/sides) - apply no-slip or slip conditions
        }
    }
     // ... (similar loops for j=0, j=grid_ny-1, k=0, k=grid_nz-1 boundaries) ...

}
// --- END NEW IMPLEMENTATION ---


// --- Placeholder Implementations for Getters (Replace with actual logic) ---
double NavierStokesSolver::get_temperature_at(const Eigen::Vector3d& pos) const {
    // TODO: Implement proper interpolation (e.g., trilinear) or nearest cell lookup
    int idx = find_cell_index_for_position(pos);
    if (idx >= 0 && idx < temperature_grid.size()) {
        return temperature_grid[idx];
    }
    // Return ambient if position is outside the grid
    return config_data["physics_parameters"]["ambient_temperature_C"].get<double>();
}

double NavierStokesSolver::get_pressure_at(const Eigen::Vector3d& pos) const {
    // TODO: Implement interpolation/lookup
    int idx = find_cell_index_for_position(pos);
     if (idx >= 0 && idx < pressure_grid.size()) {
        return pressure_grid[idx];
    }
    return 0.0; // Default pressure outside grid
}

Eigen::Vector3d NavierStokesSolver::get_velocity_at(const Eigen::Vector3d& pos) const {
    // TODO: Implement interpolation/lookup
    int idx = find_cell_index_for_position(pos);
    if (idx >= 0 && idx < velocity_grid.size()) {
        return velocity_grid[idx];
    }
    return Eigen::Vector3d::Zero(); // Default velocity outside grid
}

std::vector<double> NavierStokesSolver::get_rake_face_pressure(const Eigen::Vector3d& normal) const {
    // TODO: Implement logic to find boundary cells matching the tool face
    // and return their pressures. This requires a more sophisticated boundary representation.
    std::vector<double> pressures;
     // Placeholder: Return pressure near the center/origin
     int center_idx = find_cell_index_for_position(Eigen::Vector3d(grid_cell_size, grid_cell_size, grid_cell_size));
    if (center_idx >= 0 && center_idx < pressure_grid.size()) {
        pressures.push_back(pressure_grid[center_idx]);
    }
    return pressures;
}

// --- Grid index and position helpers (Example for simple Cartesian grid) ---
int NavierStokesSolver::get_grid_index(int i, int j, int k) const {
    // Check bounds
    if (i < 0 || i >= grid_nx || j < 0 || j >= grid_ny || k < 0 || k >= grid_nz) {
        return -1; // Indicate out of bounds
    }
    // Row-major order indexing
    return i + j * grid_nx + k * grid_nx * grid_ny;
}

Eigen::Vector3d NavierStokesSolver::get_grid_position(int i, int j, int k) const {
    // Assuming grid origin is at (0,0,0) and positions represent cell centers
    return Eigen::Vector3d(
        (i + 0.5) * grid_cell_size,
        (j + 0.5) * grid_cell_size,
        (k + 0.5) * grid_cell_size
    );
}

// Helper to find cell index for a world position (Basic implementation)
int NavierStokesSolver::find_cell_index_for_position(const Eigen::Vector3d& pos) const {
     if (grid_cell_size <= 0) return -1; // Grid not initialized

     // Convert world position to grid indices (integer division)
     int i = static_cast<int>(pos.x() / grid_cell_size);
     int j = static_cast<int>(pos.y() / grid_cell_size);
     int k = static_cast<int>(pos.z() / grid_cell_size);

     // Return the linear index using the helper function (includes bounds check)
     return get_grid_index(i, j, k);
}


// --- Main Time-Stepping Function (Placeholder - Requires CFD Algorithm) ---
void NavierStokesSolver::update(double dt) {
    // TODO: Implement the core Navier-Stokes solving algorithm here.
    // This will use the boundary conditions and heat sources applied in
    // update_boundaries_and_sources, along with the internal grid state
    // (pressure, velocity, temperature) to calculate the state at the next time step.

    // --- Placeholder: Simple Advection/Diffusion Example ---
    // This is NOT a real NS solver, just shows structure
    std::vector<double> next_temp_grid = temperature_grid;
    double alpha = 0.01; // Example thermal diffusivity
    double dx2 = grid_cell_size * grid_cell_size;

    // #pragma omp parallel for collapse(3) // Example parallelization
    for(int k=1; k<grid_nz-1; ++k) { // Iterate interior points for simple stencil
        for(int j=1; j<grid_ny-1; ++j) {
            for(int i=1; i<grid_nx-1; ++i) {
                int idx = get_grid_index(i, j, k);

                // Skip boundary cells set by the tool
                if (idx < 0 || idx >= is_boundary_cell.size() || is_boundary_cell[idx]) continue;

                // Basic explicit heat diffusion placeholder (Laplacian)
                 double T_current = temperature_grid[idx];
                 // Add bounds checks for neighbors
                 int idx_im1 = get_grid_index(i-1, j, k); double T_im1 = (idx_im1 >= 0) ? temperature_grid[idx_im1] : T_current;
                 int idx_ip1 = get_grid_index(i+1, j, k); double T_ip1 = (idx_ip1 >= 0) ? temperature_grid[idx_ip1] : T_current;
                 int idx_jm1 = get_grid_index(i, j-1, k); double T_jm1 = (idx_jm1 >= 0) ? temperature_grid[idx_jm1] : T_current;
                 int idx_jp1 = get_grid_index(i, j+1, k); double T_jp1 = (idx_jp1 >= 0) ? temperature_grid[idx_jp1] : T_current;
                 int idx_km1 = get_grid_index(i, j, k-1); double T_km1 = (idx_km1 >= 0) ? temperature_grid[idx_km1] : T_current;
                 int idx_kp1 = get_grid_index(i, j, k+1); double T_kp1 = (idx_kp1 >= 0) ? temperature_grid[idx_kp1] : T_current;

                 double laplacian = (T_im1 + T_ip1 + T_jm1 + T_jp1 + T_km1 + T_kp1 - 6.0 * T_current) / dx2;

                 // Include heat source term (W converted to Â°C/s)
                 double source_term_degC_per_s = 0.0;
                 // Assuming density and specific heat are uniform (get from config or material)
                 double density = config_data["cfd_parameters"].value("density", 1.225); // kg/m^3
                 double specific_heat = config_data["cfd_parameters"].value("specific_heat", 1005.0); // J/(kg*K)
                 double cell_volume = dx2 * grid_cell_size;
                 if (density * specific_heat * cell_volume > 1e-9 && idx >= 0 && idx < heat_source_grid.size()) {
                     source_term_degC_per_s = heat_source_grid[idx] / (density * specific_heat * cell_volume);
                 }


                 // Simple explicit Euler time step for temperature
                 next_temp_grid[idx] = T_current + dt * (alpha * laplacian + source_term_degC_per_s);

                 // Clamp temperature to prevent instability in placeholder
                 next_temp_grid[idx] = std::max(config_data["physics_parameters"]["ambient_temperature_C"].get<double>(), std::min(2000.0, next_temp_grid[idx]));
            }
        }
    }
    temperature_grid = next_temp_grid; // Update temperature grid
    // --- End Placeholder ---

    // Similar updates would be needed for pressure and velocity based on NS equations
}

// ... (Other private methods for your specific NS algorithm) ...